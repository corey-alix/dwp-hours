# In-App Notification System

## Description

Implement an in-app notification system for the DWP Hours Tracker that allows implicit messaging between administrators and employees. Administrators can trigger notifications (e.g., prompting an employee to lock their calendar) through UI actions, and employees see queued notifications when they next interact with the application after an 8+ hour session gap.

This is an **implicit messaging** system â€” admins do not compose free-form messages. Instead, notifications are generated by system actions (e.g., clicking an unlocked-calendar indicator on the admin monthly review page). A future iteration may add explicit admin-authored messages, but that is out of scope for this task.

### Key Behaviors

- Notifications are queued per-employee in the database
- Notifications are displayed when an employee starts a new session (8+ hours since last activity), reusing the existing `activityTracker.ts` session detection
- Clicking/dismissing a notification marks it as **read** â€” it will not appear again
- If a notification auto-disappears (timeout/toast expiry), it remains **unread** and will reappear on the next session start
- Admins can trigger notifications via UI actions (initial use case: unlocked calendar reminder from the monthly review page)

## Priority

ðŸŸ¡ Medium Priority â€” Enables admin-to-employee communication workflows. Depends on existing session detection infrastructure (`activityTracker.ts`). Blocks Stage 8-9 of `admin-monthly-review-design-improvements.md`.

## Checklist

### Stage 1: Database Schema

Add a `notifications` table to store queued messages per employee.

- [ ] Add `notifications` table to `db/schema.sql` with columns: `id`, `employee_id`, `type`, `message`, `created_at`, `read_at`, `created_by` (admin ID, nullable for system-generated)
- [ ] Add appropriate indexes (`employee_id`, `read_at` for unread queries)
- [ ] Add foreign keys to `employees` table
- [ ] Update `scripts/seed.ts` to include sample notifications if needed
- [ ] Update TypeORM entity definitions if using TypeORM for this table
- [ ] `pnpm run build` passes

### Stage 2: API Endpoints

Create REST endpoints for notification CRUD operations.

- [ ] `POST /api/notifications` â€” Create a notification for a specific employee (admin-only)
  - Body: `{ employeeId: number, type: string, message: string }`
  - Returns: created notification object
- [ ] `GET /api/notifications` â€” Get unread notifications for the authenticated user
  - Query params: `?unreadOnly=true` (default)
  - Returns: array of notification objects
- [ ] `PATCH /api/notifications/:id/read` â€” Mark a notification as read
  - Sets `read_at` to current timestamp
  - Returns: updated notification object
- [ ] Add input validation using existing type guard patterns from `server.mts`
- [ ] Add authentication middleware (employee for GET/PATCH, admin for POST)
- [ ] Write Vitest tests for API endpoints
- [ ] `pnpm run build` passes
- [ ] `pnpm run lint` passes

### Stage 3: Client-Side Notification Service

Create a client-side service to fetch and manage notifications.

- [ ] Add notification API methods to `APIClient.ts` (`getNotifications()`, `markNotificationRead(id)`, `createNotification(employeeId, type, message)`)
- [ ] Create `client/shared/notificationService.ts` to orchestrate notification fetching on session start
- [ ] Integrate with `isFirstSessionVisit()` from `activityTracker.ts` â€” fetch unread notifications on new sessions
- [ ] Expose notifications to the existing `TraceListener` / `PtoNotificationController` pipeline for display
- [ ] `pnpm run build` passes
- [ ] `pnpm run lint` passes

### Stage 4: Notification Display in UI

Display queued notifications to employees using the existing notification/toast infrastructure.

- [ ] On session start (8+ hour gap), fetch unread notifications and display them via the `TraceListener`
- [ ] Each notification is shown as a toast/banner with a dismiss button
- [ ] Clicking the dismiss button calls `PATCH /api/notifications/:id/read` to mark as read
- [ ] If the toast auto-dismisses (timeout), do **not** mark as read â€” it will reappear next session
- [ ] Style notifications consistently with existing toast styles
- [ ] Ensure notifications respect `prefers-reduced-motion` for any enter/exit animations
- [ ] `pnpm run build` passes
- [ ] `pnpm run lint` passes

### Stage 5: Admin Notification Trigger (Monthly Review Integration)

Wire the admin monthly review page's unlocked-calendar indicator to create notifications.

- [ ] In `admin-monthly-review/index.ts`, add click handler for the unlocked indicator
- [ ] On click, call `POST /api/notifications` with the employee ID and a system message (e.g., "Please review and lock your calendar for [Month]")
- [ ] Show confirmation toast to the admin after successful notification creation
- [ ] Prevent duplicate notifications (check if an unread notification of the same type already exists for the employee/month)
- [ ] `pnpm run build` passes
- [ ] `pnpm run lint` passes

### Stage 6: Testing and Quality Gates

- [ ] Write Vitest unit tests for `notificationService.ts`
- [ ] Write Vitest tests for notification display logic
- [ ] Write E2E test for admin creating a notification and employee seeing it
- [ ] Manual testing of the full flow: admin triggers notification â†’ employee sees it on next session â†’ dismisses â†’ doesn't reappear
- [ ] Manual testing of auto-dismiss: notification timeout â†’ reappears next session
- [ ] `pnpm run build` passes
- [ ] `pnpm run lint` passes
- [ ] `pnpm run lint:css` passes

## Implementation Notes

- **Session detection**: Reuse `client/shared/activityTracker.ts` (`isFirstSessionVisit()` / `updateActivityTimestamp()`) â€” this already detects 8+ hour gaps. The existing `UIManager.checkPriorMonthAcknowledgement()` method demonstrates the pattern for session-start actions.
- **Notification display**: Use the existing `TraceListener` â†’ `PtoNotificationController` pipeline. The `notifications.info()` call in `UIManager.ts` shows how to surface messages to the user.
- **Database**: Follow existing patterns in `db/schema.sql`. Use `TEXT` for dates (consistent with other tables). Consider a `type` column for categorizing notifications (e.g., `calendar_lock_reminder`, `system`) to support future notification types.
- **API patterns**: Follow existing endpoint patterns in `server.mts` with type guards, `authenticate`/`authenticateAdmin` middleware, and proper error handling.
- **No admin compose UI**: This iteration only supports implicit/system-generated notifications triggered by admin actions. No free-form message composition UI is needed.
- **Notification types**: Use a string enum/union for notification types to allow future extensibility (e.g., `calendar_lock_reminder` | `pto_approval` | `system`).
- **Duplicate prevention**: Before creating a notification, check for existing unread notifications of the same type for the same employee/month to avoid spamming.

## Questions and Concerns

1. Should notifications have an expiration date (e.g., auto-expire after 30 days)? YES, only show notifications created within the last 30 days. Add `expires_at` column to the database and filter out expired notifications in the GET endpoint.
2. Should there be a notification bell/badge icon in the app header showing unread count, or only show notifications on session start?
   SESSION START ONLY â€” no bell indicator. Future iteration may add mobile web app push notifications.
3. Should the system support notification preferences (e.g., employee can opt out of certain notification types)? NO.
4. What is the appropriate auto-dismiss timeout for toast notifications before they are considered "not seen"? DEFINE in BusinessRules.ts (5 seconds).
5. Should read notifications be retained in the database for audit purposes, or purged after a retention period? RETAIN.
